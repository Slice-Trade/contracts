# Slice smart contracts    

# Introduction

The Slice smart contract architecture is designed to provide users with exposure to a basket of underlying assets through a single token, the Slice token. This ERC20 token represents a diversified portfolio of cryptocurrencies, with the underlying assets residing on various blockchains. Users purchase Slice tokens on a single chain. Our architecture utilizes the LayerZero bridge for cross-chain messaging.

Key components of the Slice architecture include two smart contracts: `SliceCore.sol` and `SliceToken.sol`. `SliceCore.sol` serves as the core logic deployed across multiple blockchains. It facilitates cross-chain messaging and contains essential logic utilized by `SliceToken.sol`. `SliceToken.sol` is the ERC20 token representing the underlying assets and enabling users to access them.   
The `SliceCore.sol` contract will be deployed to the same address across all blockchains.

The three most important smart contract interactions are the following:

- **create** new Slice tokens
- **mint** a Slice token
- **redeem** a Slice token for the underlying assets

plus optionally:
- if a mint fails, the user can trigger a **refund**   

## Create

In the create step an address that is allowed to create new Slice tokens calls the `createSlice()` function on the `SliceCore.sol` smart contract. What addresses are allowed to create Slice tokens will depend on the strategic/business decisions of the team (can specify anything from a single address to all addresses).

In the `createSlice()` function, the creator has to input a list of positions.
A position contains:

- the chain ID
- the token address    
- the token decimals   
- the units (i.e. 0.5 ETH, 20 LINK, etc.)

The result of the create step is that a new SliceToken.sol contract is deployed.

![Slice Smart Contract Architecture](https://github.com/Slice-Trade/contracts/assets/44027725/da210997-63bf-4078-9191-9f493c7b8bad)

## Mint

In the mint step the end user calls the `mint()` function on the `SliceToken.sol` smart contract via the front end.   
For the mint to succeed, the user must own all the underlying assets on the correct blockchains prior to the mint.

The mint steps are as follows:

1. (Outside of our smart contracts) the user approves the `SliceCore.sol` contract to spend the required amounts of all underlying ERC20 assets
2. The user calls the `mint(uint256 _sliceTokenQuantity)` function on the Slice token the user wants to mint (the input parameter is the quantity of slice tokens the user is minting)
3. The Slice token contract calls the `collectUnderlying(bytes32 _mintID)` on the `SliceCore.sol` contract. Here `_mintID` is an ID generated by the `SliceToken.sol` contract for this mint.
4. The `SliceCore.sol` contract gets the mint details based on the `_mintID` provided, it goes through each underlying asset and if the asset is local, it simply transfers it to the contract. If the asset is cross-chain, it creates a signal for each underlying asset, groups them by chain, and sends one LayerZero message per chain to the corresponding `SliceCore.sol` contract on that chain
5. On the destination chain, LayerZero calls the `lzReceive` function on the `SliceCore.sol` contract.
6. The core contract handles the incoming `lzReceive` message, in this case transferring all underlying assets to itself.
7. The core contract sends back a confirmation LayerZero message to the origin chain. For each underlying asset, it contains whether the transfer was successful or not.
8. LayerZero calls `lzReceive` on the origin chain `SliceCore.sol` contract.
9. If all the transfers were successful, the core contract calls `mintComplete(bytes32 _mintID)` on the Slice token. The Slice token then mints `_sliceTokenQuantity` amount of tokens to the user. If some of the transfers failed, the core contract calls `mintFailed(bytes32 _mintID)` on the Slice token. The state of the mint is updated to failed and the user can now call refund to get back the tokens that did manage to transfer successfully.

The result of the successful mint step is a new Slice token in the user's wallet on the main blockchain used for slice tokens.

![ManualMint-Technical](https://github.com/Slice-Trade/contracts/assets/44027725/a50c74f6-b811-4423-9eeb-2d9df7bd3bc2)

## Redeem

In the redeem step, the owner of a Slice token is able to exchange a Slice token for the underlying assets the Slice token represents. 

The redeem steps are as follows:

- user calls the `redeem()` function on the `SliceToken.sol` contract using the front end
- token contract locks the token (so it can’t be transferred once in redeem state)
- all the underlying assets are transferred to the user’s wallet
- when all redeem successful notifications are received, the token is burned

![Slice Smart Contract Architecture (3)](https://github.com/Slice-Trade/contracts/assets/44027725/ddb78d4a-4227-43c1-a24c-7277e121d925)     

## Refund

A mint can fail if:
- the user did not have the required amounts of all the underlying assets
- the user did not approve the `SliceCore.sol` contract to spend the required amounts of all the underlying assets

In this case, we end up with a situation where some of the underlying assets are in the contract, while some are not. In this case, the user does not get the slice tokens, and the user can trigger `refund` where the user gets back the assets that were successfully transferred.

The refund steps are as follows:
1. The user becomes aware that the mint failed (either through using our frontend or checking our smart contracts directly)
2. The user calls the `refund(bytes32 _mintID)` function on the `SliceToken.sol` contract
3. The `SliceToken.sol` contract checks that the mint with `_mintID` exists, and that its state is `FAILED`, then it updates the state to `REFUNDING` and calls the `refund(SliceTransactionInfo memory _txInfo)` function on the `SliceCore.sol` contract
4. The core contract checks if there is a success/failure signal recorded for all the underlying assets. If there is not, the refund reverts. If all the signals are received, the core contract goes through the list of the assets that were successfully transferred to the contract, groups them by blockchain, and then sends one LayerZero message per blockchain with the refund information to the core contract on that blockchain
5. On the destination chain, LayerZero calls the `lzReceive` function on the `SliceCore.sol` contract
6. The `SliceCore.sol` contract transfers the assets back to the user
7. The core contract sends back a confirmation LayerZero message to the origin chain
8. When all the LayerZero messages are received, the state of the mint is updated to `REFUNDED`

![Refund](https://github.com/Slice-Trade/contracts/assets/44027725/5cc0bd56-7cef-498f-9e3f-10f45e523030)

# Getting started
## Requirements
- [foundry](https://getfoundry.sh/)     
  To install foundry:
  ```bash
  curl -L https://foundry.paradigm.xyz | bash
  ```
  Follow the instructions on screen then run:
  ```bash
  foundryup
  ```

## Quickstart
```bash
git clone https://github.com/Slice-Trade/contracts.git
cd contracts
make
```

## Usage
### Testing
```bash
forge test
```
### Coverage
```bash
forge coverage
```

### Deploying to testnets
```bash
cp .env.sample .env
```
- Update the variables in the `.env` file with your own RPC URLs, key, etc.
- Add executable permissions to the deploy script and then deploy to Optimism Sepolia testnet:
```bash
chmod +x deploy.sh && ./deploy.sh op-sepolia
```
- Deploy to Base Sepolia testnet:
```bash
./deploy.sh base-sepolia
```

## Compatibilities
- Solc version: 0.8.26
- Chains to deploy contracts to: Ethereum Mainnet, Optimism, Base,

## Roles
- **Owner**: The deployer of the `SliceCore.sol` contract. Using OpenZeppelin `Ownable.sol` for ownership. 
  The owner can do the following:
  - turn Slice token creation on or off
  - approve and revoke approval for an address to create Slice tokens
  - update the gas values used in the options for the cross-chain LayerZero messages

- **Slice token creator**: Granted by the owner, this role can deploy a new Slice token by calling `createSlice` on the `SliceCore.sol` contract
- **User**: Can execute `mint`, `redeem`, and `refund` on `SliceToken.sol` and the `external view` functions on `SliceToken.sol` and `SliceCore.sol`
