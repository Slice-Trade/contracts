# Slice smart contracts    

# Introduction

The Slice smart contract architecture is designed to provide users with exposure to a basket of underlying assets through a single token, the Slice token. This ERC20 token represents a diversified portfolio of cryptocurrencies, with the underlying assets residing on various blockchains. Users purchase Slice tokens on a single chain. Our architecture utilizes the LayerZero bridge for cross-chain messaging.

Key components of the Slice architecture include two smart contracts: `SliceCore.sol` and `SliceToken.sol`. `SliceCore.sol` serves as the core logic deployed across multiple blockchains. It facilitates cross-chain messaging and contains essential logic utilized by `SliceToken.sol`. `SliceToken.sol` is the ERC20 token representing the underlying assets and enabling users to access them.   
The `SliceCore.sol` contract will be deployed to the same address across all blockchains.

The three most important smart contract interactions are the following:

- **create** new Slice tokens
- **mint** a Slice token
- **redeem** a Slice token for the underlying assets

plus optionally:
- if a mint fails, the user can trigger a **refund**   

## Create

In the create step an address that is allowed to create new Slice tokens calls the `createSlice()` function on the `SliceCore.sol` smart contract. What addresses are allowed to create Slice tokens will depend on the strategic/business decisions of the team (can specify anything from a single address to all addresses).

In the `createSlice()` function, the creator has to input a list of positions.
A position contains:

- the chain ID
- the token address    
- the token decimals   
- the units (i.e. 0.5 ETH, 20 LINK, etc.)

The result of the create step is that a new SliceToken.sol contract is deployed.

![Slice Smart Contract Architecture](https://github.com/Slice-Trade/contracts/assets/44027725/da210997-63bf-4078-9191-9f493c7b8bad)

## Mint

In the mint step the end user calls the `mint()` function on the `SliceToken.sol` smart contract via the front end.   
For the mint to succeed, the user must own all the underlying assets on the correct blockchains prior to the mint.

The mint steps are as follows:

1. (Outside of our smart contracts) the user approves the `SliceCore.sol` contract to spend the required amounts of all underlying ERC20 assets
2. The user calls the `mint(uint256 _sliceTokenQuantity)` function on the Slice token the user wants to mint (the input parameter is the amount of slice tokens the user is minting)
3. The Slice token contract calls the `collectUnderlyingAssets(bytes32 _mintID)` on the `SliceCore.sol` contract. Here `_mintID` is an ID generated by the `SliceToken.sol` contract for this mint.
4. The `SliceCore.sol` contract gets the mint details based on the `_mintID` provided, it goes through each underlying asset and if the asset is local, it simply transfers it to the contract. If the asset is cross-chain, it creates a signal for each underlying asset, groups them by chain, and sends one LayerZero message per chain to the corresponding `SliceCore.sol` contract on that chain
5. On the destination chain, LayerZero calls the `lzReceive` function on the `SliceCore.sol` contract.
6. The core contract handles the incoming `lzReceive` message, in this case transferring all underlying assets to itself.
7. The core contract sends back a confirmation LayerZero message to the origin chain. For each underlying asset, it contains whether the transfer was successful or not.
8. LayerZero calls `lzReceive` on the origin chain `SliceCore.sol` contract.
9. If all the transfers were successful, the core contract calls `mintComplete(bytes32 _mintID)` on the Slice token. The Slice token then mints `_sliceTokenQuantity` amount of tokens to the user. If some of the transfers failed, the core contract calls `mintFailed(bytes32 _mintID)` on the Slice token. The state of the mint is updated to failed and the user can now call refund to get back the tokens that did manage to transfer successfully.

The result of the successful mint step is a new Slice token in the user's wallet on the main blockchain used for slice tokens.

![ManualMint-Technical](https://github.com/Slice-Trade/contracts/assets/44027725/a50c74f6-b811-4423-9eeb-2d9df7bd3bc2)

## Redeem

In the redeem step, the owner of a Slice token is able to exchange a Slice token for the underlying assets the Slice token represents. 

The redeem steps are as follows:

- user calls the `redeem()` function on the `SliceToken.sol` contract using the front end
- token contract locks the token (so it can’t be transferred once in redeem state)
- all the underlying assets are transferred to the user’s wallet
- when all redeem successful notifications are received, the token is burned

![Slice Smart Contract Architecture (3)](https://github.com/Slice-Trade/contracts/assets/44027725/ddb78d4a-4227-43c1-a24c-7277e121d925)     

